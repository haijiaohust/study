题目：数组中有三个数只出现一次，其它的数恰好出现两次，找出这三个数。

 

    先考虑“只有两个数出现一次”的情况：可以找到一种方法，将数组划分为两部分，且让这两个数分别在不同部分，这样每部分所有数的异或值，恰好分别等于这两个数。一种简单的分法就是，先计算出这两个数的异或值M（等价于求数组中所有数的异或值），求出M值的二进制表示中的最低位1（其它位的1也可以，只不过麻烦点）在 +k位，然后根据 +k位是否为1，将原数组分为两部分。

   

    回到原题，假设这三个不同的数是：A、B、C，它们的异或值 X = A xor B xor C，X值可能为0，也可能不为0。当X值不为0时（比如：这三个数为3、5、7，X值为1），很难找到一种方法，将原来的数组划分为两部分，使得这三个数不都在同一部分。因而，要先对原来的数组进行一次替换：将每个数与X进行异或。这样原来的三个数就变成了：

B xor C、A xor C、A xor B。记a = B xor C、b = A xor C、c = A xor B。新的异或值 x = a xor b xor c = 0。

   

    由于A、B、C互不相等，显然它们间的异或值a、b、c都不为0，且互不相等。（若a等于b，则 0 = a xor b = (B xor C) xor (A xor C) = A xor B != 0自相矛盾）

  

若三个数的异或值为0，且其中一个数在 +n位（n为任意值）上为1，则另两个数在 +n位上必然一个为1，另一个为0（不然的话，这三个数的异或值就不会为0），因而根据 +n位为1，可以将这三个数分成两部分。

 

设f(x)为x的二进制表示中最低位1的位置，则f(a)、f(b)、f(c)这三个数中有且只有两个数相等。证明：不妨设f(a)、f(b)、f(c)中最小的是f(a)，k = f(a)，则b、c在 +k位上必然是一个为1，一个为0，不妨设b在 +k位为1，则根据f(x)的定义以及f(a)最小，可得f(b)等于f(a)，f(c)大于f(a)。因而，新数组的数x对应的所有f(x)的总异或值等于f(c)。

 

假设f(a)等于f(b)，m = f(c)，由于c在 +m位上为1，不妨设 b在 +m位也为1，则a在 +m位为0。根据 +m位是否为1，可将新数组分为两部分，每部分的异或值恰好都是 a = B xor C，可以求出数A（等于a xor X）。 将数A放入原来的数组，问题转为“只有两个数出现一次”的情况，利用前面提到的方法算出另两个数。总共需遍历数组4次。